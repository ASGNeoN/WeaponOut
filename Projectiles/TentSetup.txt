using Microsoft.Xna.Framework;
using Microsoft.Xna.Framework.Graphics;
using Terraria;
using Terraria.ID;
using Terraria.ModLoader;

namespace WeaponOut.Projectiles
{
    /// <summary>
    /// 
    /// </summary>
    public class TentSetup : ModProjectile
    {
		private const int fWidth = 80;
		private const int fHeight = 48;
        private const int tentSetupCounter = 10;
        private const int tentComplete = tentSetupCounter * 15;

        public override void SetDefaults()
        {
            projectile.name = "Tent Setup";
            projectile.width = 80;
            projectile.height = 48;
            projectile.friendly = true;
            projectile.tileCollide = false;
            projectile.penetrate = -1;

            Main.projFrames[projectile.type] = 16;
        }

		public override void AI()
		{
			Player player = Main.player[projectile.owner];
			player.itemTime = 2;

            if (projectile.ai[0] == 0) //when spawned, align appropriately
            {
                projectile.frame = 0;
                projectile.direction = player.direction;
                projectile.spriteDirection = projectile.direction;
                projectile.position.X = (int)((projectile.position.X + 8) / 16) * 16;
                projectile.position.Y = (int)((projectile.position.Y + 8) / 16) * 16 + 2;
            }
			
			projectile.frameCounter = (int)projectile.ai[0];
            if (projectile.ai[0] >= tentSetupCounter * (1 + projectile.frame))
			{
                projectile.frame++; //increases fram by 1
                projectile.netUpdate2 = true;
                CheckEmpty();
			}
            if (projectile.ai[0] > tentComplete) //end of animation
            {
                projectile.netUpdate2 = true;
                if (player.whoAmI == Main.myPlayer) //for online, only player does projectile
                {
                    ushort tType = mod.GetTile("CampTent").Type;
                    int tX = (int)((projectile.position.X) / 16) - 3;
                    int tY = (int)((projectile.position.Y) / 16) + 2;

                    //custom code because no support in placetile
                    Place5x3(tX + 5, tY, tType, player.direction, 0);
                    
                    WorldGen.SquareTileFrame(tX, tY);
                    Main.PlaySound(0, tX * 16, tY * 16, 1);
                    if (Main.netMode == 1)
                    {
                        //update squares around projectile point
                        //NetMessage.SendTileSquare(-1, tX, tY - 2, 7);
                        NetMessage.SendData(20, -1, -1, "", 7, (float)(tX - 3), (float)(tY - 4), 0f, 0, 0, 0);
                        //NetMessage.SendData(0, -1, -1, "", 1, tX, tY, tType, 0, 0, 0);
                    }
                }
				projectile.Kill();
			}
			else
			{
				if(player.itemAnimation == 1) //reset animation constantly until complete
				{
					player.itemAnimation = player.inventory[player.selectedItem].useAnimation;
					Main.PlaySound(0, (int)player.position.X, (int)player.position.Y, 0);
				}
			}

            projectile.ai[0]++;
		}
		
		private void CheckEmpty() //check all tiles around are empty
		{
			Player player = Main.player[projectile.owner];
            int item = -1;
            bool cancel = player.velocity != default(Vector2);
            if (!cancel)
            {
                if (!IsEmptyTiles(projectile.position, projectile.width, projectile.height))
                {
                    cancel = true;
                    if (player.whoAmI == Main.myPlayer) //message to player
                    {
                        Main.NewText("Not enough space to setup", 255, 240, 20, false);
                    }
                }
            }
            if (cancel) 
            {
                projectile.Kill();
                item = Item.NewItem(
                    (int)(projectile.position.X + projectile.width / 2),
                    (int)(projectile.position.Y + projectile.height / 2),
                    0, 0,
                    mod.ItemType("CampTent"), 1,
                    false, 0, false, false);
                if (Main.netMode == 1 && item >= 0)
                {
                    //net message of item being made
                    NetMessage.SendData(21, -1, -1, "", item, 1f, 0f, 0f, 0, 0, 0);
                }
            }
        }
		
        /// <summary>
        /// Checks if all tiles within width and height of a position are free
        /// </summary>
        /// <param name="pos"></param>
        /// <param name="w"></param>
        /// <param name="h"></param>
        /// <returns></returns>
		private bool IsEmptyTiles(Vector2 pos, float w, float h)
		{
			int bottom = 0;
			for(int y = 0; y < (int)(h / 16); y++)
			{
				for(int x = 0; x < (int)(w / 16); x++)
				{
					int tX = (int)((pos.X + 8) / 16) + x;
					int tY = (int)((pos.Y) / 16) + y;
					//Dust.NewDust(new Vector2((float)(tX * 16) + 8, (float)(tY * 16) + 8), 0, 0, 6, 0f, 0f, 0, default(Color), 1f);
					if(tX < 0 || tX > Main.maxTilesX || tY < 0 || tY > Main.maxTilesY) return false;
					Tile tile = Main.tile[tX, tY];
					if(tile.type != 0) return false;
				}
				bottom++;
			}
			for(int x = 0; x < (int)(w / 16); x++)
			{
				int tX = (int)((pos.X + 8) / 16) + x;
				int tY = (int)((pos.Y) / 16) + bottom;
				//Dust.NewDust(new Vector2((float)(tX * 16) + 8, (float)(tY * 16) + 8), 0, 0, 6, 0f, 0f, 0, default(Color), 1f);
				if(tX < 0 || tX > Main.maxTilesX || tY < 0 || tY > Main.maxTilesY) return false;
				Tile tile = Main.tile[tX, tY];
				if(tile.collisionType != 1) return false;
			}
			return true;
		}

        public override void Kill(int timeLeft)
        {
            Main.player[projectile.owner].itemAnimation = 0;
		}

        public override bool PreDraw(SpriteBatch sb, Color c)
        {
            Player player = Main.player[projectile.owner];
            Texture2D graphic = Main.projectileTexture[projectile.type];
            Vector2 halfFrame = new Vector2(fWidth / 2, fHeight / 2);
            Vector2 projGraphOffset = projectile.position + new Vector2(projectile.width / 2, projectile.height / 2);
            Color projColour = Lighting.GetColor((int)(player.Center.X / 16f), (int)(player.Center.Y / 16f));
            SpriteEffects effects = SpriteEffects.None;
            if (projectile.spriteDirection == -1)
            {
                effects = SpriteEffects.FlipHorizontally;
            }

            sb.Draw(
                graphic,
                projGraphOffset - Main.screenPosition,
                new Rectangle(0, fHeight * projectile.frame, fWidth, fHeight),
                projColour,
                projectile.rotation,
                halfFrame,//rotate about projectile point
                projectile.scale,
                effects,
                0f
            );
            return false;
		}


        private void Place5x3(int x, int y, ushort type, int direction = -1, int style = 0)
        {
            if (x < 5 || x > Main.maxTilesX - 5 || y < 5 || y > Main.maxTilesY - 5)
            {
                return;
            }
            bool flag = true;
            for (int i = x - 2; i < x + 3; i++)
            {
                for (int j = y - 2; j < y + 1; j++)
                {
                    if (Main.tile[i, j] == null)
                    {
                        Main.tile[i, j] = new Tile();
                    }
                    if (Main.tile[i, j].active())
                    {
                        flag = false;
                    }
                }
                if (Main.tile[i, y + 1] == null)
                {
                    Main.tile[i, y + 1] = new Tile();
                }
                if (!WorldGen.SolidTile2(i, y + 1))
                {
                    flag = false;
                }
            }
            short num = 0;
            if (direction == 1)
            {
                num = 18 * 5;
            }
            int num2 = 18 * 3 * style;
            if (flag)
            {
                for (int i = -2; i < 3; i++)
                {
                    for (int j = -2; j < 1; j++)
                    {
                        Main.tile[x + i, y + j].active(true);
                        Main.tile[x + i, y + j].frameY = (short)((j + 2) * 18 + num2);
                        Main.tile[x + i, y + j].frameX = (short)((i + 2) * 18 + num);
                        Main.tile[x + i, y + j].type = type;
                    }
                }
            }
        }
	}
}